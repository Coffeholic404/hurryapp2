import { defineNuxtModule, createResolver, addComponent, addPlugin } from '@nuxt/kit';
import plugin from 'tailwindcss/plugin.js';
import { getIconCSS, parseIconSet } from '@iconify/utils';
import path from 'path';
import fs from 'fs';
import { createRequire } from 'module';
import { defu } from 'defu';

const availableCollectionNames = ["material-symbols", "ic", "mdi", "ph", "solar", "tabler", "ri", "bi", "carbon", "iconamoon", "ion", "uil", "tdesign", "teenyicons", "mingcute", "clarity", "iconoir", "majesticons", "zondicons", "ant-design", "bx", "bxs", "gg", "octicon", "cil", "lucide", "basil", "pixelarticons", "system-uicons", "ci", "akar-icons", "memory", "typcn", "radix-icons", "ep", "circum", "mdi-light", "fe", "eos-icons", "charm", "prime", "humbleicons", "uiw", "uim", "uit", "uis", "maki", "gridicons", "mi", "quill", "gala", "fluent", "icon-park-outline", "icon-park-solid", "icon-park-twotone", "icon-park", "vscode-icons", "jam", "heroicons", "codicon", "pajamas", "pepicons-pop", "pepicons-print", "pepicons-pencil", "bytesize", "ei", "streamline", "guidance", "fa6-solid", "fa6-regular", "ooui", "nimbus", "formkit", "line-md", "meteocons", "svg-spinners", "openmoji", "twemoji", "noto", "fluent-emoji", "fluent-emoji-flat", "fluent-emoji-high-contrast", "noto-v1", "emojione", "emojione-monotone", "emojione-v1", "fxemoji", "streamline-emojis", "bxl", "logos", "simple-icons", "cib", "fa6-brands", "nonicons", "arcticons", "file-icons", "devicon", "devicon-plain", "skill-icons", "brandico", "entypo-social", "cryptocurrency", "cryptocurrency-color", "flag", "circle-flags", "flagpack", "cif", "gis", "map", "geo", "game-icons", "fad", "academicons", "wi", "healthicons", "medical-icon", "covid", "la", "eva", "dashicons", "flat-color-icons", "entypo", "foundation", "raphael", "icons8", "iwwa", "heroicons-outline", "heroicons-solid", "fa-solid", "fa-regular", "fa-brands", "fa", "fluent-mdl2", "fontisto", "icomoon-free", "subway", "oi", "wpf", "simple-line-icons", "et", "el", "vaadin", "grommet-icons", "whh", "si-glyph", "zmdi", "ls", "bpmn", "flat-ui", "vs", "topcoat", "il", "websymbol", "fontelico", "ps", "feather", "mono-icons", "pepicons"];

const req = createRequire(import.meta.url);
const localResolve = (cwd, id) => {
  try {
    const resolved = req.resolve(id, { paths: [cwd] });
    return resolved;
  } catch {
    return null;
  }
};
function callerPath() {
  const error = new Error();
  const stack = error.stack?.split("\n");
  const data = stack.find(
    (line) => !line.trim().startsWith("Error") && !line.includes("(") && !line.includes(")")
  );
  if (!data) {
    return null;
  }
  const filePathPattern = new RegExp(
    // eslint-disable-next-line no-useless-escape
    /\s*at (\/.*|[a-zA-Z]:\\(?:([^<>:"\/\\|?*]*[^<>:"\/\\|?*.]\\|..\\)*([^<>:"\/\\|?*]*[^<>:"\/\\|?*.]\\?|..\\))?):\d+:\d+/i
  );
  const result = filePathPattern.exec(data);
  if (!result) {
    return null;
  }
  return result[1];
}
const isPackageExists = (id) => {
  const p = callerPath();
  const cwd = p ? path.dirname(p) : process.cwd();
  return Boolean(localResolve(cwd, id));
};
const getIconCollections = (include = "all") => {
  const p = callerPath();
  const cwd = p ? path.dirname(p) : process.cwd();
  const pkgPath = localResolve(cwd, "@iconify/json/package.json");
  if (!pkgPath) {
    if (Array.isArray(include)) {
      return include.reduce((result, name) => {
        const jsonPath = localResolve(cwd, `@iconify-json/${name}/icons.json`);
        if (!jsonPath) {
          throw new Error(
            `Icon collection "${name}" not found. Please install @iconify-json/${name} or @iconify/json`
          );
        }
        return {
          ...result,
          [name]: req(jsonPath)
        };
      }, {});
    }
    if (include === "all") {
      throw new Error(
        `All icon collections requested. Please install @iconify/json`
      );
    }
    return {};
  }
  const pkgDir = path.dirname(pkgPath);
  const files = fs.readdirSync(path.join(pkgDir, "json"));
  const collections = {};
  for (const file of files) {
    if (include === "all" || include.includes(file.replace(".json", ""))) {
      const json = req(path.join(pkgDir, "json", file));
      collections[json.prefix] = json;
    }
  }
  return collections;
};
const getAutoIconCollections = (collections) => {
  if (Array.isArray(collections)) {
    return getIconCollections(collections);
  }
  if (typeof collections === "object")
    return collections;
  const names = collections === "all" ? "all" : availableCollectionNames.filter(
    (name) => isPackageExists(`@iconify-json/${name}`)
  );
  return getIconCollections(names);
};
const getCustomCollections = (customCollections) => {
  if (typeof customCollections === "string") {
    const json = req(customCollections);
    return {
      [json.prefix]: json
    };
  }
  if (Array.isArray(customCollections)) {
    return customCollections.reduce((result, collection) => {
      if (typeof collection === "string") {
        const json = req(collection);
        return {
          ...result,
          [json.prefix]: json
        };
      }
      return {
        ...result,
        ...collection
      };
    }, {});
  }
  return customCollections;
};
const generateIconComponent = (data, options) => {
  const css = getIconCSS(data, {});
  const rules = {};
  css.replace(/^\s+([^:]+):\s*([^;]+);/gm, (_, prop, value) => {
    if (prop === "width" || prop === "height") {
      rules[prop] = `${options.scale}em`;
    } else {
      rules[prop] = value;
    }
    return "";
  });
  Object.assign(rules, { verticalAlign: "middle" });
  if (options.extraProperties) {
    Object.assign(rules, options.extraProperties);
  }
  return rules;
};

const iconsPlugin = (iconsPluginOptions) => {
  const {
    collections: propsCollections,
    customCollections = {},
    scale = 1,
    prefix = "i",
    extraProperties = {}
  } = iconsPluginOptions ?? {};
  const collections = defu(
    {},
    getAutoIconCollections(propsCollections),
    getCustomCollections(customCollections)
  );
  const components = {};
  const collectionPrefixes = [];
  if (prefix)
    components[prefix] = {};
  for (const colPrefix of Object.keys(collections)) {
    collectionPrefixes.push(prefix ? `${prefix}-${colPrefix}` : `${colPrefix}`);
    const collection = {
      ...collections[colPrefix],
      prefix: colPrefix
    };
    if (!prefix)
      components[colPrefix] = {};
    parseIconSet(collection, (name, data) => {
      if (!data || !name)
        return;
      const key = prefix ? `${colPrefix}-${name}` : `${name}`;
      components[prefix || colPrefix][key] = generateIconComponent(data, {
        scale,
        extraProperties
      });
    });
  }
  if (iconsPluginOptions)
    iconsPluginOptions.resolvedPrefixes = collectionPrefixes;
  return plugin(({ matchComponents }) => {
    for (const twPrefix of Object.keys(components)) {
      matchComponents(
        {
          [twPrefix]: (value) => {
            if (typeof value === "string")
              return components[twPrefix][value];
            return value;
          }
        },
        {
          values: components[twPrefix]
        }
      );
    }
  });
};

const module = defineNuxtModule({
  meta: {
    name: "nuxt-icon-tw",
    configKey: "icon",
    compatibility: {
      nuxt: "^3.0.0"
    }
  },
  defaults: {
    tailwindOnly: false,
    resolvedPrefixes: [],
    prefix: "i",
    scale: 1
  },
  setup(options, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    const twPlugin = iconsPlugin(options);
    nuxt.options.runtimeConfig.public.tailwindIcons = defu(
      nuxt.options.runtimeConfig.public.tailwindIcons,
      options
    );
    nuxt.hook("schema:extend", (schemas) => {
      schemas.push({
        appConfig: {
          nuxtIcon: {
            $schema: {
              title: "Nuxt Icon",
              description: "Configure the defaults of Nuxt Icon"
            },
            size: {
              $default: "1em",
              $schema: {
                title: "Icon Size",
                description: "Set the default icon size. Set to false to disable the sizing of icon in style.",
                tags: ["@studioIcon material-symbols:format-size-rounded"],
                tsType: "string | false"
              }
            },
            class: {
              $default: "",
              $schema: {
                title: "CSS Class",
                description: "Set the default CSS class",
                tags: ["@studioIcon material-symbols:css"]
              }
            },
            aliases: {
              $default: {},
              $schema: {
                title: "Icon aliases",
                description: "Define Icon aliases to update them easily without code changes.",
                tags: [
                  "@studioIcon material-symbols:star-rounded",
                  "@studioInputObjectValueType icon"
                ],
                tsType: "{ [alias: string]: string }"
              }
            },
            iconifyApiOptions: {
              url: {
                $default: "https://api.iconify.design",
                $schema: {
                  title: "Iconify API URL",
                  description: "Define a custom Iconify API URL. Useful if you want to use a self-hosted Iconify API. Learn more: https://iconify.design/docs/api/"
                }
              },
              publicApiFallback: {
                $default: false,
                $schema: {
                  title: "Public Iconify API fallback",
                  description: "Define, if the public Iconify API should be used as fallback if the ."
                }
              }
            },
            prefix: {
              $default: "i",
              $schema: {
                title: "Tailwind Class Prefix",
                description: "Set the Tailwind class prefix; leave bank or null to not use a prefix"
              }
            },
            resolvedPrefixes: {
              $default: [],
              $schema: {
                title: "Resolved Prefixes",
                description: "All of the icon collections loaded by Tailwind.",
                tsType: "string[]"
              }
            }
          }
        }
      });
    });
    addComponent({
      name: "Icon",
      global: true,
      filePath: resolve("./runtime/Icon.vue"),
      priority: 10
    });
    addComponent({
      name: "IconSvg",
      global: true,
      filePath: resolve("./runtime/IconSvg.vue")
    });
    addComponent({
      name: "IconTw",
      global: true,
      filePath: resolve("./runtime/IconTw.vue")
    });
    addPlugin(resolve("./runtime/plugin"));
    nuxt.hook("tailwindcss:config", (config) => {
      if (!config.plugins)
        config.plugins = [];
      config.plugins.push(twPlugin);
    });
    nuxt.hook("devtools:customTabs", (iframeTabs) => {
      iframeTabs.push({
        name: "icones",
        title: "Ic\xF4nes",
        icon: "i-arcticons-iconeration",
        view: {
          type: "iframe",
          src: "https://icones.js.org"
        }
      });
    });
  }
});

export { module as default };
